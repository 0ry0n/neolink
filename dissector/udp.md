# BcUDP

This document describes the UDP protocol. UDP, unlike TCP, is lossy, there
is no guarantee that all packets sent will be received or that they are received
in the same order. As such the protocol involves sending meta data back and forth
where the camera and client acknowledge packets they have received.

Additionally the UDP max data size is smaller so packets will be split more
perhaps even several UDP packets per BC message, whereas in TCP the Bc messages were
always in one TCP packet.

# Packets Types

There are three types of UDP packets with their own header

- UDP Discovery: These packets have the magic `3acf872a` and contain encrypted
                 xml about the connection that will be used
- UDP Ack:       These packets have the magic `20cf872a` they are header only and
                 contain acknowledgement of packets
- UDP Data:      These packets contain part of a BC messagse with a special UDP
                 header that describes the udp message number, to help reassemble
                 the packets. They have the magic: `10cf872a`

# UDP Discovery

These messages are sent as part of the initial connection discovery.
It is a sequence of messages with different xmls.

If there is no reply is received within  500ms the last message is resent.

## Header 20 Bytes

- 4 Bytes magic: `3acf872a`
- 4 Bytes data size: Size in bytes of payload
- 4 Bytes unknown: Always `01000000` for for UDP Discovery
- 4 Bytes Transmission ID: The unique ID of the transmission, every successful
                           round trip of Discovery it is incremented.
                           The number is the same for the same transmission
                           and may be used to identify repeated messages.
                           It is also used for the encryption.
- 4 Bytes Checksum: The checksum of the payload encrypted payload

The checksum can be calculated with this rust code:

```rust
const TABLE: [u32; 1024] = [0x0, 0x0, 0x0, 0x0, 0x96, 0x30, 0x7, 0x77, 0x2C, 0x61, 0xE, 0xEE, 0xBA, 0x51, 0x9, 0x99, 0x19, 0xC4, 0x6D, 0x7, 0x8F, 0xF4, 0x6A, 0x70, 0x35, 0xA5, 0x63, 0xE9, 0xA3, 0x95, 0x64, 0x9E, 0x32, 0x88, 0xDB, 0xE, 0xA4, 0xB8, 0xDC, 0x79, 0x1E, 0xE9, 0xD5, 0xE0, 0x88, 0xD9, 0xD2, 0x97, 0x2B, 0x4C, 0xB6, 0x9, 0xBD, 0x7C, 0xB1, 0x7E, 0x7, 0x2D, 0xB8, 0xE7, 0x91, 0x1D, 0xBF, 0x90, 0x64, 0x10, 0xB7, 0x1D, 0xF2, 0x20, 0xB0, 0x6A, 0x48, 0x71, 0xB9, 0xF3, 0xDE, 0x41, 0xBE, 0x84, 0x7D, 0xD4, 0xDA, 0x1A, 0xEB, 0xE4, 0xDD, 0x6D, 0x51, 0xB5, 0xD4, 0xF4, 0xC7, 0x85, 0xD3, 0x83, 0x56, 0x98, 0x6C, 0x13, 0xC0, 0xA8, 0x6B, 0x64, 0x7A, 0xF9, 0x62, 0xFD, 0xEC, 0xC9, 0x65, 0x8A, 0x4F, 0x5C, 0x1, 0x14, 0xD9, 0x6C, 0x6, 0x63, 0x63, 0x3D, 0xF, 0xFA, 0xF5, 0xD, 0x8, 0x8D, 0xC8, 0x20, 0x6E, 0x3B, 0x5E, 0x10, 0x69, 0x4C, 0xE4, 0x41, 0x60, 0xD5, 0x72, 0x71, 0x67, 0xA2, 0xD1, 0xE4, 0x3, 0x3C, 0x47, 0xD4, 0x4, 0x4B, 0xFD, 0x85, 0xD, 0xD2, 0x6B, 0xB5, 0xA, 0xA5, 0xFA, 0xA8, 0xB5, 0x35, 0x6C, 0x98, 0xB2, 0x42, 0xD6, 0xC9, 0xBB, 0xDB, 0x40, 0xF9, 0xBC, 0xAC, 0xE3, 0x6C, 0xD8, 0x32, 0x75, 0x5C, 0xDF, 0x45, 0xCF, 0xD, 0xD6, 0xDC, 0x59, 0x3D, 0xD1, 0xAB, 0xAC, 0x30, 0xD9, 0x26, 0x3A, 0x0, 0xDE, 0x51, 0x80, 0x51, 0xD7, 0xC8, 0x16, 0x61, 0xD0, 0xBF, 0xB5, 0xF4, 0xB4, 0x21, 0x23, 0xC4, 0xB3, 0x56, 0x99, 0x95, 0xBA, 0xCF, 0xF, 0xA5, 0xBD, 0xB8, 0x9E, 0xB8, 0x2, 0x28, 0x8, 0x88, 0x5, 0x5F, 0xB2, 0xD9, 0xC, 0xC6, 0x24, 0xE9, 0xB, 0xB1, 0x87, 0x7C, 0x6F, 0x2F, 0x11, 0x4C, 0x68, 0x58, 0xAB, 0x1D, 0x61, 0xC1, 0x3D, 0x2D, 0x66, 0xB6, 0x90, 0x41, 0xDC, 0x76, 0x6, 0x71, 0xDB, 0x1, 0xBC, 0x20, 0xD2, 0x98, 0x2A, 0x10, 0xD5, 0xEF, 0x89, 0x85, 0xB1, 0x71, 0x1F, 0xB5, 0xB6, 0x6, 0xA5, 0xE4, 0xBF, 0x9F, 0x33, 0xD4, 0xB8, 0xE8, 0xA2, 0xC9, 0x7, 0x78, 0x34, 0xF9, 0x0, 0xF, 0x8E, 0xA8, 0x9, 0x96, 0x18, 0x98, 0xE, 0xE1, 0xBB, 0xD, 0x6A, 0x7F, 0x2D, 0x3D, 0x6D, 0x8, 0x97, 0x6C, 0x64, 0x91, 0x1, 0x5C, 0x63, 0xE6, 0xF4, 0x51, 0x6B, 0x6B, 0x62, 0x61, 0x6C, 0x1C, 0xD8, 0x30, 0x65, 0x85, 0x4E, 0x0, 0x62, 0xF2, 0xED, 0x95, 0x6, 0x6C, 0x7B, 0xA5, 0x1, 0x1B, 0xC1, 0xF4, 0x8, 0x82, 0x57, 0xC4, 0xF, 0xF5, 0xC6, 0xD9, 0xB0, 0x65, 0x50, 0xE9, 0xB7, 0x12, 0xEA, 0xB8, 0xBE, 0x8B, 0x7C, 0x88, 0xB9, 0xFC, 0xDF, 0x1D, 0xDD, 0x62, 0x49, 0x2D, 0xDA, 0x15, 0xF3, 0x7C, 0xD3, 0x8C, 0x65, 0x4C, 0xD4, 0xFB, 0x58, 0x61, 0xB2, 0x4D, 0xCE, 0x51, 0xB5, 0x3A, 0x74, 0x0, 0xBC, 0xA3, 0xE2, 0x30, 0xBB, 0xD4, 0x41, 0xA5, 0xDF, 0x4A, 0xD7, 0x95, 0xD8, 0x3D, 0x6D, 0xC4, 0xD1, 0xA4, 0xFB, 0xF4, 0xD6, 0xD3, 0x6A, 0xE9, 0x69, 0x43, 0xFC, 0xD9, 0x6E, 0x34, 0x46, 0x88, 0x67, 0xAD, 0xD0, 0xB8, 0x60, 0xDA, 0x73, 0x2D, 0x4, 0x44, 0xE5, 0x1D, 0x3, 0x33, 0x5F, 0x4C, 0xA, 0xAA, 0xC9, 0x7C, 0xD, 0xDD, 0x3C, 0x71, 0x5, 0x50, 0xAA, 0x41, 0x2, 0x27, 0x10, 0x10, 0xB, 0xBE, 0x86, 0x20, 0xC, 0xC9, 0x25, 0xB5, 0x68, 0x57, 0xB3, 0x85, 0x6F, 0x20, 0x9, 0xD4, 0x66, 0xB9, 0x9F, 0xE4, 0x61, 0xCE, 0xE, 0xF9, 0xDE, 0x5E, 0x98, 0xC9, 0xD9, 0x29, 0x22, 0x98, 0xD0, 0xB0, 0xB4, 0xA8, 0xD7, 0xC7, 0x17, 0x3D, 0xB3, 0x59, 0x81, 0xD, 0xB4, 0x2E, 0x3B, 0x5C, 0xBD, 0xB7, 0xAD, 0x6C, 0xBA, 0xC0, 0x20, 0x83, 0xB8, 0xED, 0xB6, 0xB3, 0xBF, 0x9A, 0xC, 0xE2, 0xB6, 0x3, 0x9A, 0xD2, 0xB1, 0x74, 0x39, 0x47, 0xD5, 0xEA, 0xAF, 0x77, 0xD2, 0x9D, 0x15, 0x26, 0xDB, 0x4, 0x83, 0x16, 0xDC, 0x73, 0x12, 0xB, 0x63, 0xE3, 0x84, 0x3B, 0x64, 0x94, 0x3E, 0x6A, 0x6D, 0xD, 0xA8, 0x5A, 0x6A, 0x7A, 0xB, 0xCF, 0xE, 0xE4, 0x9D, 0xFF, 0x9, 0x93, 0x27, 0xAE, 0x0, 0xA, 0xB1, 0x9E, 0x7, 0x7D, 0x44, 0x93, 0xF, 0xF0, 0xD2, 0xA3, 0x8, 0x87, 0x68, 0xF2, 0x1, 0x1E, 0xFE, 0xC2, 0x6, 0x69, 0x5D, 0x57, 0x62, 0xF7, 0xCB, 0x67, 0x65, 0x80, 0x71, 0x36, 0x6C, 0x19, 0xE7, 0x6, 0x6B, 0x6E, 0x76, 0x1B, 0xD4, 0xFE, 0xE0, 0x2B, 0xD3, 0x89, 0x5A, 0x7A, 0xDA, 0x10, 0xCC, 0x4A, 0xDD, 0x67, 0x6F, 0xDF, 0xB9, 0xF9, 0xF9, 0xEF, 0xBE, 0x8E, 0x43, 0xBE, 0xB7, 0x17, 0xD5, 0x8E, 0xB0, 0x60, 0xE8, 0xA3, 0xD6, 0xD6, 0x7E, 0x93, 0xD1, 0xA1, 0xC4, 0xC2, 0xD8, 0x38, 0x52, 0xF2, 0xDF, 0x4F, 0xF1, 0x67, 0xBB, 0xD1, 0x67, 0x57, 0xBC, 0xA6, 0xDD, 0x6, 0xB5, 0x3F, 0x4B, 0x36, 0xB2, 0x48, 0xDA, 0x2B, 0xD, 0xD8, 0x4C, 0x1B, 0xA, 0xAF, 0xF6, 0x4A, 0x3, 0x36, 0x60, 0x7A, 0x4, 0x41, 0xC3, 0xEF, 0x60, 0xDF, 0x55, 0xDF, 0x67, 0xA8, 0xEF, 0x8E, 0x6E, 0x31, 0x79, 0xBE, 0x69, 0x46, 0x8C, 0xB3, 0x61, 0xCB, 0x1A, 0x83, 0x66, 0xBC, 0xA0, 0xD2, 0x6F, 0x25, 0x36, 0xE2, 0x68, 0x52, 0x95, 0x77, 0xC, 0xCC, 0x3, 0x47, 0xB, 0xBB, 0xB9, 0x16, 0x2, 0x22, 0x2F, 0x26, 0x5, 0x55, 0xBE, 0x3B, 0xBA, 0xC5, 0x28, 0xB, 0xBD, 0xB2, 0x92, 0x5A, 0xB4, 0x2B, 0x4, 0x6A, 0xB3, 0x5C, 0xA7, 0xFF, 0xD7, 0xC2, 0x31, 0xCF, 0xD0, 0xB5, 0x8B, 0x9E, 0xD9, 0x2C, 0x1D, 0xAE, 0xDE, 0x5B, 0xB0, 0xC2, 0x64, 0x9B, 0x26, 0xF2, 0x63, 0xEC, 0x9C, 0xA3, 0x6A, 0x75, 0xA, 0x93, 0x6D, 0x2, 0xA9, 0x6, 0x9, 0x9C, 0x3F, 0x36, 0xE, 0xEB, 0x85, 0x67, 0x7, 0x72, 0x13, 0x57, 0x0, 0x5, 0x82, 0x4A, 0xBF, 0x95, 0x14, 0x7A, 0xB8, 0xE2, 0xAE, 0x2B, 0xB1, 0x7B, 0x38, 0x1B, 0xB6, 0xC, 0x9B, 0x8E, 0xD2, 0x92, 0xD, 0xBE, 0xD5, 0xE5, 0xB7, 0xEF, 0xDC, 0x7C, 0x21, 0xDF, 0xDB, 0xB, 0xD4, 0xD2, 0xD3, 0x86, 0x42, 0xE2, 0xD4, 0xF1, 0xF8, 0xB3, 0xDD, 0x68, 0x6E, 0x83, 0xDA, 0x1F, 0xCD, 0x16, 0xBE, 0x81, 0x5B, 0x26, 0xB9, 0xF6, 0xE1, 0x77, 0xB0, 0x6F, 0x77, 0x47, 0xB7, 0x18, 0xE6, 0x5A, 0x8, 0x88, 0x70, 0x6A, 0xF, 0xFF, 0xCA, 0x3B, 0x6, 0x66, 0x5C, 0xB, 0x1, 0x11, 0xFF, 0x9E, 0x65, 0x8F, 0x69, 0xAE, 0x62, 0xF8, 0xD3, 0xFF, 0x6B, 0x61, 0x45, 0xCF, 0x6C, 0x16, 0x78, 0xE2, 0xA, 0xA0, 0xEE, 0xD2, 0xD, 0xD7, 0x54, 0x83, 0x4, 0x4E, 0xC2, 0xB3, 0x3, 0x39, 0x61, 0x26, 0x67, 0xA7, 0xF7, 0x16, 0x60, 0xD0, 0x4D, 0x47, 0x69, 0x49, 0xDB, 0x77, 0x6E, 0x3E, 0x4A, 0x6A, 0xD1, 0xAE, 0xDC, 0x5A, 0xD6, 0xD9, 0x66, 0xB, 0xDF, 0x40, 0xF0, 0x3B, 0xD8, 0x37, 0x53, 0xAE, 0xBC, 0xA9, 0xC5, 0x9E, 0xBB, 0xDE, 0x7F, 0xCF, 0xB2, 0x47, 0xE9, 0xFF, 0xB5, 0x30, 0x1C, 0xF2, 0xBD, 0xBD, 0x8A, 0xC2, 0xBA, 0xCA, 0x30, 0x93, 0xB3, 0x53, 0xA6, 0xA3, 0xB4, 0x24, 0x5, 0x36, 0xD0, 0xBA, 0x93, 0x6, 0xD7, 0xCD, 0x29, 0x57, 0xDE, 0x54, 0xBF, 0x67, 0xD9, 0x23, 0x2E, 0x7A, 0x66, 0xB3, 0xB8, 0x4A, 0x61, 0xC4, 0x2, 0x1B, 0x68, 0x5D, 0x94, 0x2B, 0x6F, 0x2A, 0x37, 0xBE, 0xB, 0xB4, 0xA1, 0x8E, 0xC, 0xC3, 0x1B, 0xDF, 0x5, 0x5A, 0x8D, 0xEF, 0x02, 0x2D,];

pub(crate) fn calc_crc(payload: &[u8]) -> u32 {
    let mut r: u32 = 0;
    for &val in payload.iter() {
        let offset = (((val as u32 ^ r) & 0xFF) << 2) as usize;
        let val: u32 = TABLE[offset + 3] << 24
            | TABLE[offset + 2] << 16
            | TABLE[offset + 1] << 8
            | TABLE[offset];
        r = val ^ (r >> 8);
    }
    r
}
```


## Payload

- Payload can be encrypted and decrypted with this rust code

```rust
const XML_KEY: [u32; 8] = [
    0x1f2d3c4b, 0x5a6c7f8d, 0x38172e4b, 0x8271635a, 0x863f1a2b, 0xa5c6f7d8, 0x8371e1b4, 0x17f2d3a5,
];

pub(crate) fn decrypt(offset: u32, buf: &[u8]) -> Vec<u8> {
    let key = XML_KEY
        .iter()
        .map(|i| (i + offset).to_le_bytes())
        .flatten()
        .cycle();
    buf.iter().zip(key).map(|(byte, key)| key ^ byte).collect()
}
```

## Start Discovery payload

Client send this packet as a broadcast on 255.255.255.255 on port 2015
to init a connection

```xml
<P2P>
  <C2D_S>
    <to>
      <port>57268</port>
    </to>
  </C2D_S>
</P2P>
```

It also sends this binary on port 2000 as a broadcast

```
aaaa0000
```

---

**Camera Replies with Binary**

Camera replies with binary data to port 3000

This data seems to include the
- Camera name
- ip address
- TCP port
- Camera UID


**Tcp camera**

If the camera supports tcp the client will use this binary data to open a
standard tcp bc connection

**Udp Camera**

If the camera supports UDP the client will send this xml packet
as a broadcast on 255.255.255.255 on port 2018/2015

**Known UID**

If the UID is already known you can skip to this step.

```xml
<P2P>
  <C2D_C>
    <uid>95270000YGAKNWKJ</uid>
    <cli>
      <port>24862</port>
    </cli>
    <cid>849013</cid>
    <mtu>1350</mtu>
    <debug>0</debug>
    <p>MAC</p>
  </C2D_C>
</P2P>
```

**Both**

A camera can do both of the above. In this case it will try to login
to both udp and tcp. Then the udp will disconnect.

---

## D2C_C_R Payload Camera

Camera replies with this payload on the port specified in `C2D_C`

```xml
<P2P>
  <D2C_C_R>
    <timer>
      <def>3000</def>
      <hb>10000</hb>
      <hbt>60000</hbt>
    </timer>
    <rsp>0</rsp>
    <cid>849013</cid>
    <did>192</did>
  </D2C_C_R>
</P2P>
```

- **timer** Unknown timer of some sort`
- **rsp**: Unknown
- **cid**: The connection ID of the client
- **did**: The connection ID of the camera



## T Payload Client

Client then replies with this.

```xml
<P2P>
  <C2D_T>
    <sid>62097899</sid>
    <conn>local</conn>
    <cid>82000</cid>
    <mtu>1350</mtu>
  </C2D_T>
</P2P>
```

- **sid**: ID of the camera
- **conn**: Type of connection only observed `local` value
- **cid**: The connection ID of the client
- **did**: The connection ID of the camera
- **mtu**: The maximum transmission unit of the connection. Which is the
           largest packet size in bytes


## T Payload Camera

Camera replies with this payload on the port specified in `C2D_C`

**Login**

The client can now login over UDP


## Dissconnect

After a message ID 02 (logout) the client send this

```xml
<P2P>
  <C2D_DISC>
    <cid>82000</cid>
    <did>80</did>
  </C2D_DISC>
</P2P>
```

- **cid**: The connection ID of the client
- **did**: The connection ID of the camera

The camera also send it but with a `D2C_DISC` tag

## Other

Some cameras seem to also send this before login

```xml
<P2P>
  <D2C_CFM>
    <sid>62097899</sid>
    <conn>local</conn>
    <rsp>0</rsp>
    <cid>82000</cid>
    <did>80</did>
    <time_r>0</time_r>
  </D2C_CFM>
</P2P>
```

- **sid**: ID of the camera
- **conn**: Type of connection only observed `local` value
- **rsp**: Unknown always 0
- **cid**: The connection ID of the client
- **did**: The connection ID of the camera
- **time_r**: Should be the time but it is always 0

# UDP Ack

These messages are sent to acknowledge receipt of message. They are header only.

## Header 28 Bytes

- 4 Bytes magic: `20cf872a`
- 4 Bytes Connection ID: This is the connection ID negotiated during UDP Discovery
- 4 Bytes unknown: Always `00000000` for for UDP Ack
- 4 Bytes unknown: Always `00000000` for for UDP Ack
- 4 Bytes Last Packet ID: Last received packet id
- 4 Bytes Unknown: Observed values `00000000`, `d6010000`, `d7160000` `09e00000` **NEEDS INFO**
- Payload Size
- Paload

**To Investigate:**
  - Why does the unknown byte change. It starts at zero and remains that way
    for a second. Then seems to change and remain at the new value for another second

Here's an example of a UDP Ack payload (size 203 bytes)

```hex
0000   00 01 01 01 01 01 01 01 01 01 01 01 00 01 01 01
0010   01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
0020   01 01 01 01 00 01 01 01 01 01 01 01 01 01 01 01
0030   01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
0040   01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
0050   01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
0060   01 01 01 01 01 01 00 01 01 01 01 01 01 01 01 01
0070   01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
0080   01 01 01 01 01 01 01 01 01 01 00 01 01 01 01 01
0090   01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
00a0   01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
00b0   01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
00c0   01 01 01 01 01 01 01 01 01 01 01 01
```

The payload is a truth table. If the packet ID in header is 50
then the first byte corresponds to packet id 51, the second 52
etc etc. If the byte if `00` then the camera will resend that packet

If this payload is allowed to grow to ~ 205 bytes the camera sends a
disconnect request and drops the connection



# UDP Data

UDP data packets contain the BC packets with an extra header.

Whenever a packet is received a UDP Ack is sent. If the sender of the packet
does not get the Ack within 1000ms it resends the packet

## Header 20 Bytes

- 4 Bytes magic: `10cf872a`
- 4 Bytes Connection ID: This is the connection ID negotiated during UDP Discovery
- 4 Bytes unknown: Always `00000000` for for UDP Data
- 4 Bytes Packet ID: The ID of the packet mono-atomically increases for each new packet
- 4 Bytes Payload Size: Size of UDP payload in bytes

## Payload

The payload is a standard Bc Packet
